import os
import tempfile
import logging
import subprocess
import asyncio
from typing import Dict, Any

from ..core.config import settings

logger = logging.getLogger(__name__)


class MalwareScanError(Exception):
    """Exception raised for malware scanning errors."""
    pass


class MalwareDetected(Exception):
    """Exception raised when malware is detected."""
    pass


class MalwareScanner:
    """Malware scanning service with multiple scanning backends."""
    
    def __init__(self):
        self.clamav_available = self._check_clamav_availability()
        self.enabled = getattr(settings, 'MALWARE_SCANNING_ENABLED', True)
        
        if self.enabled:
            logger.info(f"Malware scanner initialized. ClamAV available: {self.clamav_available}")
        else:
            logger.info("Malware scanning is disabled")

    def _check_clamav_availability(self) -> bool:
        """Check if ClamAV is available on the system."""
        try:
            result = subprocess.run(
                ['clamscan', '--version'], 
                capture_output=True, 
                text=True, 
                timeout=5
            )
            return result.returncode == 0
        except (subprocess.TimeoutExpired, FileNotFoundError, Exception):
            return False

    async def scan_file_content(self, file_content: bytes, filename: str) -> Dict[str, Any]:
        """
        Scan file content for malware using available scanners.
        
        Args:
            file_content: Raw file content bytes
            filename: Original filename for context
            
        Returns:
            Dictionary with scan results
            
        Raises:
            MalwareDetected: If malware is found
            MalwareScanError: If scanning fails
        """
        if not self.enabled:
            return {
                'scanned': False,
                'scanner': 'disabled',
                'clean': True,
                'message': 'Malware scanning is disabled'
            }
        
        scan_results = []
        
        # Create temporary file for scanning
        with tempfile.NamedTemporaryFile(delete=False, suffix='.tmp') as temp_file:
            temp_file.write(file_content)
            temp_path = temp_file.name
        
        try:
            # Try ClamAV first if available
            if self.clamav_available:
                try:
                    clamav_result = await self._scan_with_clamav(temp_path, filename)
                    scan_results.append(clamav_result)
                    
                    if not clamav_result['clean']:
                        raise MalwareDetected(f"Malware detected by ClamAV: {clamav_result['threat_name']}")
                        
                except MalwareDetected:
                    raise
                except Exception as e:
                    logger.warning(f"ClamAV scan failed: {e}")
                    scan_results.append({
                        'scanner': 'clamav',
                        'clean': None,
                        'error': str(e)
                    })
            
            # Add signature-based detection as fallback
            try:
                signature_result = await self._signature_based_scan(file_content, filename)
                scan_results.append(signature_result)
                
                if not signature_result['clean']:
                    raise MalwareDetected(f"Suspicious pattern detected: {signature_result['threat_name']}")
                    
            except MalwareDetected:
                raise
            except Exception as e:
                logger.warning(f"Signature scan failed: {e}")
                scan_results.append({
                    'scanner': 'signature',
                    'clean': None,
                    'error': str(e)
                })
            
            # If we have at least one successful clean scan, consider it clean
            clean_scans = [r for r in scan_results if r.get('clean') is True]
            
            if not clean_scans and scan_results:
                # All scans either failed or found threats
                failed_scans = [r for r in scan_results if r.get('clean') is None]
                if len(failed_scans) == len(scan_results):
                    # All scans failed
                    raise MalwareScanError("All malware scans failed")
            
            return {
                'scanned': True,
                'scanner': 'multi',
                'clean': True,
                'scan_results': scan_results,
                'message': f'File scanned with {len(scan_results)} scanner(s)'
            }
            
        finally:
            # Clean up temporary file
            try:
                os.unlink(temp_path)
            except Exception as e:
                logger.warning(f"Failed to clean up temp file {temp_path}: {e}")

    async def _scan_with_clamav(self, file_path: str, filename: str) -> Dict[str, Any]:
        """Scan file using ClamAV."""
        try:
            # Run clamscan with appropriate options
            process = await asyncio.create_subprocess_exec(
                'clamscan',
                '--no-summary',
                '--infected',
                '--stdout',
                file_path,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=30)
            
            stdout_str = stdout.decode('utf-8', errors='ignore')
            stderr_str = stderr.decode('utf-8', errors='ignore')
            
            if process.returncode == 0:
                # Clean file
                return {
                    'scanner': 'clamav',
                    'clean': True,
                    'threat_name': None,
                    'output': stdout_str
                }
            elif process.returncode == 1:
                # Infected file
                threat_name = 'unknown'
                if 'FOUND' in stdout_str:
                    lines = stdout_str.strip().split('\n')
                    for line in lines:
                        if 'FOUND' in line:
                            parts = line.split(':')
                            if len(parts) >= 2:
                                threat_name = parts[1].strip().replace(' FOUND', '')
                            break
                
                return {
                    'scanner': 'clamav',
                    'clean': False,
                    'threat_name': threat_name,
                    'output': stdout_str
                }
            else:
                # Error
                raise MalwareScanError(f"ClamAV scan error (code {process.returncode}): {stderr_str}")
                
        except asyncio.TimeoutError:
            raise MalwareScanError("ClamAV scan timed out")
        except Exception as e:
            raise MalwareScanError(f"ClamAV scan failed: {str(e)}")

    async def _signature_based_scan(self, file_content: bytes, filename: str) -> Dict[str, Any]:
        """Perform signature-based malware detection."""
        try:
            # Known malware signatures and suspicious patterns
            malware_signatures = [
                # Common malware patterns
                (b'\x4d\x5a\x90\x00', 'PE_Executable_Header'),
                (b'\x7f\x45\x4c\x46', 'ELF_Executable'),
                (b'\xca\xfe\xba\xbe', 'Java_Class_File'),
                (b'\xfe\xed\xfa\xce', 'Mach-O_Binary'),
                
                # Script injections
                (b'<script', 'JavaScript_Code'),
                (b'javascript:', 'JavaScript_URL'),
                (b'vbscript:', 'VBScript_Code'),
                (b'<?php', 'PHP_Code'),
                (b'<%', 'Server_Side_Script'),
                
                # Command injection patterns
                (b'cmd.exe', 'Windows_Command'),
                (b'powershell', 'PowerShell_Command'),
                (b'/bin/sh', 'Unix_Shell'),
                (b'/bin/bash', 'Bash_Shell'),
                
                # Suspicious PowerShell patterns
                (b'Start-Process', 'PowerShell_Process_Start'),
                (b'Invoke-Expression', 'PowerShell_Code_Execution'),
                (b'Invoke-WebRequest', 'PowerShell_Web_Request'),
                (b'DownloadString', 'PowerShell_Download'),
                
                # Archive bombs (nested archives)
                (b'PK\x03\x04', 'ZIP_Archive'),
                (b'Rar!', 'RAR_Archive'),
                (b'\x1f\x8b', 'GZIP_Archive'),
            ]
            
            detected_threats = []
            
            # Check for known malware signatures
            for signature, threat_name in malware_signatures:
                if signature in file_content:
                    detected_threats.append(threat_name)
            
            # Additional heuristic checks
            
            # Check for high entropy (possible encrypted/packed content)
            if len(file_content) > 1000:  # Only for larger files
                entropy = self._calculate_entropy(file_content[:1000])  # Check first 1KB
                if entropy > 7.5:  # Very high entropy
                    detected_threats.append('High_Entropy_Content')
            
            # Check for suspicious repeated patterns
            if len(file_content) > 100:
                unique_bytes = len(set(file_content[:1000]))
                if unique_bytes < 10:  # Very low diversity
                    detected_threats.append('Low_Entropy_Content')
            
            # Check file size vs content ratio for possible zip bombs
            if b'PK\x03\x04' in file_content and len(file_content) < 1000:
                # Small ZIP file could be a zip bomb
                detected_threats.append('Possible_Zip_Bomb')
            
            if detected_threats:
                return {
                    'scanner': 'signature',
                    'clean': False,
                    'threat_name': ', '.join(detected_threats),
                    'threats': detected_threats
                }
            else:
                return {
                    'scanner': 'signature',
                    'clean': True,
                    'threat_name': None,
                    'threats': []
                }
                
        except Exception as e:
            raise MalwareScanError(f"Signature scan failed: {str(e)}")

    def _calculate_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy of data."""
        if not data:
            return 0
        
        # Count frequency of each byte value
        frequency = {}
        for byte in data:
            frequency[byte] = frequency.get(byte, 0) + 1
        
        # Calculate entropy
        entropy = 0
        data_len = len(data)
        
        for count in frequency.values():
            probability = count / data_len
            if probability > 0:
                entropy -= probability * (probability.bit_length() - 1)
        
        return entropy

    async def scan_url_reputation(self, url: str) -> Dict[str, Any]:
        """
        Check URL reputation (if file was uploaded from URL).
        This would integrate with services like VirusTotal, URLVoid, etc.
        """
        # Placeholder for URL reputation checking
        return {
            'scanned': False,
            'clean': True,
            'message': 'URL reputation scanning not implemented'
        }


# Global scanner instance
malware_scanner = MalwareScanner()


async def scan_file_for_malware(file_content: bytes, filename: str) -> Dict[str, Any]:
    """
    Convenience function to scan file content for malware.
    
    Args:
        file_content: Raw file content bytes
        filename: Original filename
        
    Returns:
        Dictionary with scan results
        
    Raises:
        MalwareDetected: If malware is found
        MalwareScanError: If scanning fails
    """
    return await malware_scanner.scan_file_content(file_content, filename)