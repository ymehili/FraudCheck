name: Deploy to AWS ECS

on:
  push:
    branches: [deploy]
  workflow_dispatch:

env:
  AWS_REGION: us-east-2
  ECR_BACKEND_REPOSITORY: checkguard-backend
  ECR_FRONTEND_REPOSITORY: checkguard-frontend
  ECS_CLUSTER: checkguard-cluster
  ECS_BACKEND_SERVICE: backend
  ECS_FRONTEND_SERVICE: frontend
  ECS_CELERY_SERVICE: celery-worker

permissions:
  id-token: write
  contents: read

jobs:
  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get commit SHA
        id: get-sha
        run: echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Build backend image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.get-sha.outputs.sha_short }}
        run: |
          echo "Building backend image for linux/amd64..."
          docker build --platform linux/amd64 -t $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG backend/
          docker build --platform linux/amd64 -t $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:latest backend/
          
          echo "Pushing backend image to ECR..."
          docker push $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:latest

      - name: Build frontend image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.get-sha.outputs.sha_short }}
        run: |
          echo "Building frontend image for linux/amd64..."
          docker build --platform linux/amd64 \
            --build-arg NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY="${{ secrets.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY }}" \
            --build-arg NEXT_PUBLIC_API_BASE_URL="${{ secrets.NEXT_PUBLIC_API_BASE_URL }}" \
            -t $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG frontend/
          docker build --platform linux/amd64 \
            --build-arg NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY="${{ secrets.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY }}" \
            --build-arg NEXT_PUBLIC_API_BASE_URL="${{ secrets.NEXT_PUBLIC_API_BASE_URL }}" \
            -t $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:latest frontend/
          
          echo "Pushing frontend image to ECR..."
          docker push $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:latest

      - name: Deploy or update backend service
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.get-sha.outputs.sha_short }}
        run: |
          echo "Getting current task definition..."
          TASK_DEFINITION=$(aws ecs describe-task-definition \
            --task-definition $ECS_BACKEND_SERVICE \
            --query 'taskDefinition' \
            --output json)
          
          echo "Updating image in task definition..."
          NEW_TASK_DEFINITION=$(echo $TASK_DEFINITION | jq --arg IMAGE "$ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG" \
            '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
          
          echo "Registering new task definition..."
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json "$NEW_TASK_DEFINITION" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "Checking if backend service exists..."
          if aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_BACKEND_SERVICE --query 'services[0].serviceName' --output text 2>/dev/null | grep -q $ECS_BACKEND_SERVICE; then
            echo "Service exists, updating..."
            aws ecs update-service \
              --cluster $ECS_CLUSTER \
              --service $ECS_BACKEND_SERVICE \
              --task-definition $NEW_TASK_DEF_ARN \
              --force-new-deployment
          else
            echo "Service does not exist. Please run Terraform to create the infrastructure first."
            echo "Run: cd infrastructure/terraform && terraform apply"
            exit 1
          fi

      - name: Deploy or update celery worker service
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.get-sha.outputs.sha_short }}
        run: |
          echo "Checking if celery worker service exists..."
          if aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_CELERY_SERVICE --query 'services[0].serviceName' --output text 2>/dev/null | grep -q $ECS_CELERY_SERVICE; then
            echo "Getting current task definition..."
            TASK_DEFINITION=$(aws ecs describe-task-definition \
              --task-definition $ECS_CELERY_SERVICE \
              --query 'taskDefinition' \
              --output json)
            
            echo "Updating image in task definition..."
            NEW_TASK_DEFINITION=$(echo $TASK_DEFINITION | jq --arg IMAGE "$ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG" \
              '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
            
            echo "Registering new task definition..."
            NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
              --cli-input-json "$NEW_TASK_DEFINITION" \
              --query 'taskDefinition.taskDefinitionArn' \
              --output text)
            
            echo "Updating ECS service..."
            aws ecs update-service \
              --cluster $ECS_CLUSTER \
              --service $ECS_CELERY_SERVICE \
              --task-definition $NEW_TASK_DEF_ARN \
              --force-new-deployment
          else
            echo "Celery worker service does not exist yet. Skipping for now."
            echo "This service will be created when Terraform infrastructure is applied."
          fi

      - name: Deploy or update frontend service
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.get-sha.outputs.sha_short }}
        run: |
          echo "Checking if frontend service exists..."
          if aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_FRONTEND_SERVICE --query 'services[0].serviceName' --output text 2>/dev/null | grep -q $ECS_FRONTEND_SERVICE; then
            echo "Getting current task definition..."
            TASK_DEFINITION=$(aws ecs describe-task-definition \
              --task-definition $ECS_FRONTEND_SERVICE \
              --query 'taskDefinition' \
              --output json)
            
            echo "Updating image in task definition..."
            NEW_TASK_DEFINITION=$(echo $TASK_DEFINITION | jq --arg IMAGE "$ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG" \
              '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
            
            echo "Registering new task definition..."
            NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
              --cli-input-json "$NEW_TASK_DEFINITION" \
              --query 'taskDefinition.taskDefinitionArn' \
              --output text)
            
            echo "Updating ECS service..."
            aws ecs update-service \
              --cluster $ECS_CLUSTER \
              --service $ECS_FRONTEND_SERVICE \
              --task-definition $NEW_TASK_DEF_ARN \
              --force-new-deployment
          else
            echo "Frontend service does not exist yet. Skipping for now."
            echo "This service will be created when Terraform infrastructure is applied."
          fi

      - name: Run database migrations
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.get-sha.outputs.sha_short }}
        run: |
          echo "Running database migrations..."
          
          # Get the latest backend task definition (the one we just deployed)
          LATEST_TASK_DEFINITION=$(aws ecs describe-task-definition \
            --task-definition $ECS_BACKEND_SERVICE \
            --query 'taskDefinition' \
            --output json)
          
          # Create a migration-specific task definition with direct command
          MIGRATION_TASK_DEF=$(echo $LATEST_TASK_DEFINITION | jq \
            '.containerDefinitions[0].command = ["/bin/bash", "-c", "cd /app && PATH=/home/appuser/.local/bin:$PATH PYTHONPATH=/app python -m alembic -c alembic.ini upgrade head"] |
            .containerDefinitions[0].entryPoint = [] |
            del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy) |
            .family = "migration"')
          
          echo "Registering migration task definition..."
          MIGRATION_TASK_ARN=$(aws ecs register-task-definition \
            --cli-input-json "$MIGRATION_TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "Running migration task: $MIGRATION_TASK_ARN"
          
          # Run migration task
          TASK_ARN=$(aws ecs run-task \
            --cluster $ECS_CLUSTER \
            --task-definition $MIGRATION_TASK_ARN \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$(aws ec2 describe-subnets --filters "Name=tag:Tier,Values=app" --query 'Subnets[0].SubnetId' --output text)],securityGroups=[$(aws ec2 describe-security-groups --filters "Name=tag:Name,Values=checkguard-ecs-sg" --query 'SecurityGroups[0].GroupId' --output text)],assignPublicIp=DISABLED}" \
            --query 'tasks[0].taskArn' \
            --output text)
          
          echo "Migration task started: $TASK_ARN"
          
          # Wait for migration to complete
          aws ecs wait tasks-stopped --cluster $ECS_CLUSTER --tasks $TASK_ARN
          
          # Check migration task exit code
          EXIT_CODE=$(aws ecs describe-tasks \
            --cluster $ECS_CLUSTER \
            --tasks $TASK_ARN \
            --query 'tasks[0].containers[0].exitCode' \
            --output text)
          
          if [ "$EXIT_CODE" != "0" ]; then
            echo "Migration failed with exit code: $EXIT_CODE"
            
            # Get more details about the failure
            STOPPED_REASON=$(aws ecs describe-tasks \
              --cluster $ECS_CLUSTER \
              --tasks $TASK_ARN \
              --query 'tasks[0].stoppedReason' \
              --output text)
            
            echo "Stopped reason: $STOPPED_REASON"
            
            # Try to get logs from CloudWatch
            LOG_GROUP="/aws/ecs/backend/backend-20250802155036857500000027"
            LOG_STREAM="ecs/backend/$(echo $TASK_ARN | cut -d'/' -f3)"
            echo "Checking logs in $LOG_GROUP/$LOG_STREAM"
            
            aws logs get-log-events \
              --log-group-name "$LOG_GROUP" \
              --log-stream-name "$LOG_STREAM" \
              --query 'events[].message' \
              --output text || echo "No logs available"
            
            exit 1
          fi
          
          echo "Database migration completed successfully"

      - name: Wait for deployment to complete
        run: |
          echo "Waiting for backend service to reach steady state..."
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_BACKEND_SERVICE
          
          echo "Waiting for frontend service to reach steady state..."
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_FRONTEND_SERVICE
          
          echo "Waiting for celery worker service to reach steady state..."
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_CELERY_SERVICE

      - name: Health check
        run: |
          # Get ALB DNS name
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names checkguard-alb \
            --query 'LoadBalancers[0].DNSName' \
            --output text)
          
          echo "ALB DNS: $ALB_DNS"
          
          # Health check with retry logic
          for i in {1..30}; do
            echo "Health check attempt $i..."
            if curl -f -s http://$ALB_DNS/health > /dev/null; then
              echo "‚úÖ Application health check passed!"
              break
            fi
            
            if [ $i -eq 30 ]; then
              echo "‚ùå Health check failed after 30 attempts"
              exit 1
            fi
            
            echo "Health check failed, retrying in 10 seconds..."
            sleep 10
          done
          
          echo "üöÄ Deployment completed successfully!"
          echo "Application URL: http://$ALB_DNS"
          echo "API Documentation: http://$ALB_DNS/docs"

      - name: Notify deployment success
        if: success()
        run: |
          echo "::notice title=Deployment Success::‚úÖ CheckGuard AI deployed successfully to AWS ECS"

      - name: Notify deployment failure
        if: failure()
        run: |
          echo "::error title=Deployment Failed::‚ùå CheckGuard AI deployment to AWS ECS failed"

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: failure()
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Rollback services
        run: |
          echo "üîÑ Rolling back to previous deployment..."
          
          # Force new deployment to rollback to previous version
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_BACKEND_SERVICE \
            --force-new-deployment
          
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_FRONTEND_SERVICE \
            --force-new-deployment
          
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_CELERY_SERVICE \
            --force-new-deployment
          
          echo "‚è≥ Waiting for rollback to complete..."
          
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_BACKEND_SERVICE $ECS_FRONTEND_SERVICE $ECS_CELERY_SERVICE
          
          echo "‚úÖ Rollback completed successfully"

      - name: Notify rollback
        run: |
          echo "::warning title=Rollback Completed::üîÑ Services have been rolled back to the previous version"