name: Deploy to AWS ECS

on:
  push:
    branches: [deploy]
  workflow_dispatch:

env:
  AWS_REGION: us-east-2
  ECR_BACKEND_REPOSITORY: checkguard-backend
  ECR_FRONTEND_REPOSITORY: checkguard-frontend
  ECS_CLUSTER: checkguard-cluster
  ECS_BACKEND_SERVICE: backend
  ECS_FRONTEND_SERVICE: frontend
  ECS_CELERY_SERVICE: celery-worker

permissions:
  id-token: write
  contents: read

jobs:
  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get commit SHA
        id: get-sha
        run: echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Build backend image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.get-sha.outputs.sha_short }}
        run: |
          echo "Building backend image for linux/amd64..."
          docker build --platform linux/amd64 -t $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG backend/
          docker build --platform linux/amd64 -t $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:latest backend/
          
          echo "Pushing backend image to ECR..."
          docker push $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:latest

      - name: Build frontend image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.get-sha.outputs.sha_short }}
        run: |
          echo "Building frontend image for linux/amd64..."
          docker build --platform linux/amd64 \
            --build-arg NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY="${{ secrets.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY }}" \
            --build-arg NEXT_PUBLIC_API_BASE_URL="${{ secrets.NEXT_PUBLIC_API_BASE_URL }}" \
            -t $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG frontend/
          docker build --platform linux/amd64 \
            --build-arg NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY="${{ secrets.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY }}" \
            --build-arg NEXT_PUBLIC_API_BASE_URL="${{ secrets.NEXT_PUBLIC_API_BASE_URL }}" \
            -t $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:latest frontend/
          
          echo "Pushing frontend image to ECR..."
          docker push $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:latest

      - name: Deploy or update backend service
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.get-sha.outputs.sha_short }}
        run: |
          echo "Getting current task definition..."
          TASK_DEFINITION=$(aws ecs describe-task-definition \
            --task-definition $ECS_BACKEND_SERVICE \
            --query 'taskDefinition' \
            --output json)
          
          echo "Updating image in task definition..."
          NEW_TASK_DEFINITION=$(echo $TASK_DEFINITION | jq --arg IMAGE "$ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG" \
            '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
          
          echo "Registering new task definition..."
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json "$NEW_TASK_DEFINITION" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "Checking if backend service exists..."
          if aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_BACKEND_SERVICE --query 'services[0].serviceName' --output text 2>/dev/null | grep -q $ECS_BACKEND_SERVICE; then
            echo "Service exists, updating..."
            aws ecs update-service \
              --cluster $ECS_CLUSTER \
              --service $ECS_BACKEND_SERVICE \
              --task-definition $NEW_TASK_DEF_ARN \
              --force-new-deployment
          else
            echo "Service does not exist. Please run Terraform to create the infrastructure first."
            echo "Run: cd infrastructure/terraform && terraform apply"
            exit 1
          fi

      - name: Deploy or update celery worker service
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.get-sha.outputs.sha_short }}
        run: |
          echo "Checking if celery worker service exists..."
          if aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_CELERY_SERVICE --query 'services[0].serviceName' --output text 2>/dev/null | grep -q $ECS_CELERY_SERVICE; then
            echo "Getting current task definition..."
            TASK_DEFINITION=$(aws ecs describe-task-definition \
              --task-definition $ECS_CELERY_SERVICE \
              --query 'taskDefinition' \
              --output json)
            
            echo "Updating image in task definition..."
            NEW_TASK_DEFINITION=$(echo $TASK_DEFINITION | jq --arg IMAGE "$ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG" \
              '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
            
            echo "Registering new task definition..."
            NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
              --cli-input-json "$NEW_TASK_DEFINITION" \
              --query 'taskDefinition.taskDefinitionArn' \
              --output text)
            
            echo "Updating ECS service..."
            aws ecs update-service \
              --cluster $ECS_CLUSTER \
              --service $ECS_CELERY_SERVICE \
              --task-definition $NEW_TASK_DEF_ARN \
              --force-new-deployment
          else
            echo "Celery worker service does not exist yet. Skipping for now."
            echo "This service will be created when Terraform infrastructure is applied."
          fi

      - name: Deploy or update frontend service
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.get-sha.outputs.sha_short }}
        run: |
          echo "Checking if frontend service exists..."
          if aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_FRONTEND_SERVICE --query 'services[0].serviceName' --output text 2>/dev/null | grep -q $ECS_FRONTEND_SERVICE; then
            echo "Getting current task definition..."
            TASK_DEFINITION=$(aws ecs describe-task-definition \
              --task-definition $ECS_FRONTEND_SERVICE \
              --query 'taskDefinition' \
              --output json)
            
            echo "Updating image in task definition..."
            NEW_TASK_DEFINITION=$(echo $TASK_DEFINITION | jq --arg IMAGE "$ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG" \
              '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
            
            echo "Registering new task definition..."
            NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
              --cli-input-json "$NEW_TASK_DEFINITION" \
              --query 'taskDefinition.taskDefinitionArn' \
              --output text)
            
            echo "Updating ECS service..."
            aws ecs update-service \
              --cluster $ECS_CLUSTER \
              --service $ECS_FRONTEND_SERVICE \
              --task-definition $NEW_TASK_DEF_ARN \
              --force-new-deployment
          else
            echo "Frontend service does not exist yet. Skipping for now."
            echo "This service will be created when Terraform infrastructure is applied."
          fi

      - name: Run database migrations
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.get-sha.outputs.sha_short }}
        run: |
          echo "Running database migrations..."
          
          # Get the latest backend task definition (the one we just deployed)
          LATEST_TASK_DEFINITION=$(aws ecs describe-task-definition \
            --task-definition $ECS_BACKEND_SERVICE \
            --query 'taskDefinition' \
            --output json)
          
          # Create a migration-specific task definition with direct command
          MIGRATION_TASK_DEF=$(echo $LATEST_TASK_DEFINITION | jq \
            '.containerDefinitions[0].command = ["python", "-m", "alembic", "-c", "alembic.ini", "upgrade", "head"] |
            .containerDefinitions[0].stopTimeout = 120 |
            .containerDefinitions[0].startTimeout = 600 |
            .containerDefinitions[0].essential = true |
            .taskRoleArn = .taskRoleArn |
            .executionRoleArn = .executionRoleArn |
            .cpu = "1024" |
            .memory = "2048" |
            del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy) |
            .family = "migration"')
          
          echo "Registering migration task definition..."
          MIGRATION_TASK_ARN=$(aws ecs register-task-definition \
            --cli-input-json "$MIGRATION_TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "Running migration task: $MIGRATION_TASK_ARN"
          
          # Get network configuration
          SUBNET_ID=$(aws ec2 describe-subnets --filters "Name=tag:Tier,Values=app" --query 'Subnets[0].SubnetId' --output text)
          SECURITY_GROUP_ID=$(aws ec2 describe-security-groups --filters "Name=tag:Name,Values=checkguard-ecs-sg" --query 'SecurityGroups[0].GroupId' --output text)
          
          echo "Using subnet: $SUBNET_ID"
          echo "Using security group: $SECURITY_GROUP_ID"
          
          # Run migration task
          TASK_RESPONSE=$(aws ecs run-task \
            --cluster $ECS_CLUSTER \
            --task-definition $MIGRATION_TASK_ARN \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_ID],securityGroups=[$SECURITY_GROUP_ID],assignPublicIp=DISABLED}" \
            --output json)
          
          # Check if task was created successfully
          TASK_ARN=$(echo $TASK_RESPONSE | jq -r '.tasks[0].taskArn // empty')
          if [ -z "$TASK_ARN" ]; then
            echo "Failed to start migration task"
            echo "Response: $TASK_RESPONSE"
            exit 1
          fi
          
          echo "Migration task started: $TASK_ARN"
          
          # Custom wait loop with better timeout handling
          echo "Waiting for migration task to complete..."
          MAX_ATTEMPTS=180  # 30 minutes max (180 * 10 seconds)
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            TASK_STATUS=$(aws ecs describe-tasks \
              --cluster $ECS_CLUSTER \
              --tasks $TASK_ARN \
              --query 'tasks[0].lastStatus' \
              --output text)
            
            echo "Attempt $((ATTEMPT + 1))/$MAX_ATTEMPTS: Task status is $TASK_STATUS"
            
            if [ "$TASK_STATUS" = "STOPPED" ]; then
              echo "Task has stopped"
              break
            fi
            
            # Check if task is in a failed state
            TASK_DETAILS=$(aws ecs describe-tasks \
              --cluster $ECS_CLUSTER \
              --tasks $TASK_ARN \
              --query 'tasks[0]' \
              --output json)
            
            # Extract task health status if available
            HEALTH_STATUS=$(echo $TASK_DETAILS | jq -r '.healthStatus // "UNKNOWN"')
            if [ "$HEALTH_STATUS" = "UNHEALTHY" ]; then
              echo "Task is unhealthy, checking logs..."
              break
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
            sleep 10
          done
          
          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "Migration task timed out after 30 minutes"
            TASK_STATUS="TIMEOUT"
          fi
          
          # Get final task details
          TASK_DETAILS=$(aws ecs describe-tasks \
            --cluster $ECS_CLUSTER \
            --tasks $TASK_ARN \
            --query 'tasks[0]' \
            --output json)
          
          # Check migration task exit code
          EXIT_CODE=$(echo $TASK_DETAILS | jq -r '.containers[0].exitCode // "null"')
          STOPPED_REASON=$(echo $TASK_DETAILS | jq -r '.stoppedReason // "Unknown"')
          CONTAINER_REASON=$(echo $TASK_DETAILS | jq -r '.containers[0].reason // "Unknown"')
          
          echo "Task stopped with:"
          echo "  Exit code: $EXIT_CODE"
          echo "  Stopped reason: $STOPPED_REASON"
          echo "  Container reason: $CONTAINER_REASON"
          
          # Get CloudWatch logs
          echo "Fetching CloudWatch logs..."
          
          # Get the log group from the task definition
          LOG_CONFIG=$(echo $LATEST_TASK_DEFINITION | jq -r '.containerDefinitions[0].logConfiguration')
          LOG_GROUP=$(echo $LOG_CONFIG | jq -r '.options."awslogs-group" // "/aws/ecs/backend"')
          LOG_STREAM_PREFIX=$(echo $LOG_CONFIG | jq -r '.options."awslogs-stream-prefix" // "ecs"')
          
          # Construct log stream name
          TASK_ID=$(echo $TASK_ARN | cut -d'/' -f3)
          LOG_STREAM="$LOG_STREAM_PREFIX/backend/$TASK_ID"
          
          echo "Looking for logs in: $LOG_GROUP/$LOG_STREAM"
          
          # Try to get logs with retries
          for i in {1..5}; do
            if aws logs get-log-events \
              --log-group-name "$LOG_GROUP" \
              --log-stream-name "$LOG_STREAM" \
              --query 'events[].message' \
              --output text 2>/dev/null; then
              break
            else
              echo "Logs not available yet, retrying in 5 seconds... (attempt $i/5)"
              sleep 5
            fi
          done
          
          # Also try to list available log streams if the exact stream wasn't found
          if [ $? -ne 0 ]; then
            echo "Could not find exact log stream, listing available streams:"
            aws logs describe-log-streams \
              --log-group-name "$LOG_GROUP" \
              --log-stream-name-prefix "$LOG_STREAM_PREFIX/backend" \
              --order-by LastEventTime \
              --descending \
              --max-items 5 \
              --query 'logStreams[].logStreamName' \
              --output text || echo "Could not list log streams"
          fi
          
          # Check if migration succeeded
          if [ "$EXIT_CODE" != "0" ] && [ "$EXIT_CODE" != "null" ]; then
            echo "‚ùå Migration failed with exit code: $EXIT_CODE"
            exit 1
          elif [ "$TASK_STATUS" = "TIMEOUT" ]; then
            echo "‚ùå Migration timed out"
            exit 1
          elif [ "$TASK_STATUS" != "STOPPED" ]; then
            echo "‚ùå Migration task in unexpected state: $TASK_STATUS"
            exit 1
          else
            echo "‚úÖ Database migration completed successfully"
          fi

      - name: Wait for deployment to complete
        run: |
          echo "Waiting for backend service to reach steady state..."
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_BACKEND_SERVICE
          
          echo "Waiting for frontend service to reach steady state..."
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_FRONTEND_SERVICE
          
          echo "Waiting for celery worker service to reach steady state..."
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_CELERY_SERVICE

      - name: Health check
        run: |
          # Get ALB DNS name
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names checkguard-alb \
            --query 'LoadBalancers[0].DNSName' \
            --output text)
          
          echo "ALB DNS: $ALB_DNS"
          
          # Health check with retry logic
          for i in {1..30}; do
            echo "Health check attempt $i..."
            if curl -f -s http://$ALB_DNS/health > /dev/null; then
              echo "‚úÖ Application health check passed!"
              break
            fi
            
            if [ $i -eq 30 ]; then
              echo "‚ùå Health check failed after 30 attempts"
              exit 1
            fi
            
            echo "Health check failed, retrying in 10 seconds..."
            sleep 10
          done
          
          echo "üöÄ Deployment completed successfully!"
          echo "Application URL: http://$ALB_DNS"
          echo "API Documentation: http://$ALB_DNS/docs"

      - name: Notify deployment success
        if: success()
        run: |
          echo "::notice title=Deployment Success::‚úÖ CheckGuard AI deployed successfully to AWS ECS"

      - name: Notify deployment failure
        if: failure()
        run: |
          echo "::error title=Deployment Failed::‚ùå CheckGuard AI deployment to AWS ECS failed"

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: failure()
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Rollback services
        run: |
          echo "üîÑ Rolling back to previous deployment..."
          
          # Force new deployment to rollback to previous version
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_BACKEND_SERVICE \
            --force-new-deployment
          
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_FRONTEND_SERVICE \
            --force-new-deployment
          
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_CELERY_SERVICE \
            --force-new-deployment
          
          echo "‚è≥ Waiting for rollback to complete..."
          
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_BACKEND_SERVICE $ECS_FRONTEND_SERVICE $ECS_CELERY_SERVICE
          
          echo "‚úÖ Rollback completed successfully"

      - name: Notify rollback
        run: |
          echo "::warning title=Rollback Completed::üîÑ Services have been rolled back to the previous version"