name: Deploy to AWS ECS

on:
  push:
    branches: [deploy]
  workflow_dispatch:

env:
  AWS_REGION: us-east-2
  ECR_BACKEND_REPOSITORY: checkguard-backend
  ECR_FRONTEND_REPOSITORY: checkguard-frontend
  ECS_CLUSTER: checkguard-cluster
  ECS_BACKEND_SERVICE: backend
  ECS_FRONTEND_SERVICE: frontend
  ECS_CELERY_SERVICE: celery-worker

permissions:
  id-token: write
  contents: read

jobs:
  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get commit SHA
        id: get-sha
        run: echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Build backend image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.get-sha.outputs.sha_short }}
        run: |
          echo "Building backend image..."
          docker build -t $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG backend/
          docker build -t $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:latest backend/
          
          echo "Pushing backend image to ECR..."
          docker push $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:latest

      - name: Build frontend image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.get-sha.outputs.sha_short }}
        run: |
          echo "Building frontend image..."
          docker build \
            --build-arg NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY="${{ secrets.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY }}" \
            --build-arg NEXT_PUBLIC_API_BASE_URL="${{ secrets.NEXT_PUBLIC_API_BASE_URL }}" \
            -t $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG frontend/
          docker build \
            --build-arg NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY="${{ secrets.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY }}" \
            --build-arg NEXT_PUBLIC_API_BASE_URL="${{ secrets.NEXT_PUBLIC_API_BASE_URL }}" \
            -t $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:latest frontend/
          
          echo "Pushing frontend image to ECR..."
          docker push $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:latest

      - name: Deploy or update backend service
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.get-sha.outputs.sha_short }}
        run: |
          echo "Getting current task definition..."
          TASK_DEFINITION=$(aws ecs describe-task-definition \
            --task-definition $ECS_BACKEND_SERVICE \
            --query 'taskDefinition' \
            --output json)
          
          echo "Updating image in task definition..."
          NEW_TASK_DEFINITION=$(echo $TASK_DEFINITION | jq --arg IMAGE "$ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG" \
            '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
          
          echo "Registering new task definition..."
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json "$NEW_TASK_DEFINITION" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "Checking if backend service exists..."
          if aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_BACKEND_SERVICE --query 'services[0].serviceName' --output text 2>/dev/null | grep -q $ECS_BACKEND_SERVICE; then
            echo "Service exists, updating..."
            aws ecs update-service \
              --cluster $ECS_CLUSTER \
              --service $ECS_BACKEND_SERVICE \
              --task-definition $NEW_TASK_DEF_ARN \
              --force-new-deployment
          else
            echo "Service does not exist. Please run Terraform to create the infrastructure first."
            echo "Run: cd infrastructure/terraform && terraform apply"
            exit 1
          fi

      - name: Deploy or update celery worker service
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.get-sha.outputs.sha_short }}
        run: |
          echo "Checking if celery worker service exists..."
          if aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_CELERY_SERVICE --query 'services[0].serviceName' --output text 2>/dev/null | grep -q $ECS_CELERY_SERVICE; then
            echo "Getting current task definition..."
            TASK_DEFINITION=$(aws ecs describe-task-definition \
              --task-definition $ECS_CELERY_SERVICE \
              --query 'taskDefinition' \
              --output json)
            
            echo "Updating image in task definition..."
            NEW_TASK_DEFINITION=$(echo $TASK_DEFINITION | jq --arg IMAGE "$ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG" \
              '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
            
            echo "Registering new task definition..."
            NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
              --cli-input-json "$NEW_TASK_DEFINITION" \
              --query 'taskDefinition.taskDefinitionArn' \
              --output text)
            
            echo "Updating ECS service..."
            aws ecs update-service \
              --cluster $ECS_CLUSTER \
              --service $ECS_CELERY_SERVICE \
              --task-definition $NEW_TASK_DEF_ARN \
              --force-new-deployment
          else
            echo "Celery worker service does not exist yet. Skipping for now."
            echo "This service will be created when Terraform infrastructure is applied."
          fi

      - name: Deploy or update frontend service
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.get-sha.outputs.sha_short }}
        run: |
          echo "Checking if frontend service exists..."
          if aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_FRONTEND_SERVICE --query 'services[0].serviceName' --output text 2>/dev/null | grep -q $ECS_FRONTEND_SERVICE; then
            echo "Getting current task definition..."
            TASK_DEFINITION=$(aws ecs describe-task-definition \
              --task-definition $ECS_FRONTEND_SERVICE \
              --query 'taskDefinition' \
              --output json)
            
            echo "Updating image in task definition..."
            NEW_TASK_DEFINITION=$(echo $TASK_DEFINITION | jq --arg IMAGE "$ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG" \
              '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
            
            echo "Registering new task definition..."
            NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
              --cli-input-json "$NEW_TASK_DEFINITION" \
              --query 'taskDefinition.taskDefinitionArn' \
              --output text)
            
            echo "Updating ECS service..."
            aws ecs update-service \
              --cluster $ECS_CLUSTER \
              --service $ECS_FRONTEND_SERVICE \
              --task-definition $NEW_TASK_DEF_ARN \
              --force-new-deployment
          else
            echo "Frontend service does not exist yet. Skipping for now."
            echo "This service will be created when Terraform infrastructure is applied."
          fi

      - name: Run database migrations
        run: |
          echo "Running database migrations..."
          
          # Get the current backend task definition
          TASK_DEFINITION=$(aws ecs describe-task-definition \
            --task-definition $ECS_BACKEND_SERVICE \
            --query 'taskDefinition' \
            --output json)
          
          # Create a test task first to check environment
          echo "Creating environment test task..."
          TEST_TASK_DEF=$(echo $TASK_DEFINITION | jq \
            '.containerDefinitions[0].command = ["python", "test_db_env.py"] | 
             .containerDefinitions[0].logConfiguration.options."awslogs-stream-prefix" = "env-test" |
             del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | 
             del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
          
          # Register test task definition
          TEST_TASK_ARN=$(aws ecs register-task-definition \
            --cli-input-json "$TEST_TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "Running environment test..."
          
          # Get network configuration
          PRIVATE_SUBNET=$(aws ec2 describe-subnets \
            --filters "Name=tag:Type,Values=private" \
            --query 'Subnets[0].SubnetId' \
            --output text)
          
          SECURITY_GROUP=$(aws ec2 describe-security-groups \
            --filters "Name=tag:Name,Values=checkguard-ecs-sg" \
            --query 'SecurityGroups[0].GroupId' \
            --output text)
          
          echo "Using subnet: $PRIVATE_SUBNET"
          echo "Using security group: $SECURITY_GROUP"
          
          # Run test task
          TEST_TASK_ID=$(aws ecs run-task \
            --cluster $ECS_CLUSTER \
            --task-definition $TEST_TASK_ARN \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$PRIVATE_SUBNET],securityGroups=[$SECURITY_GROUP],assignPublicIp=DISABLED}" \
            --query 'tasks[0].taskArn' \
            --output text)
          
          echo "Environment test task started: $TEST_TASK_ID"
          
          # Wait for test to complete
          aws ecs wait tasks-stopped --cluster $ECS_CLUSTER --tasks $TEST_TASK_ID
          
          # Check test results
          TEST_EXIT_CODE=$(aws ecs describe-tasks \
            --cluster $ECS_CLUSTER \
            --tasks $TEST_TASK_ID \
            --query 'tasks[0].containers[0].exitCode' \
            --output text)
          
          echo "Environment test exit code: $TEST_EXIT_CODE"
          
          if [ "$TEST_EXIT_CODE" != "0" ]; then
            echo "Environment test failed. Checking logs..."
            
            # Try to get logs
            LOG_GROUP=$(echo $TASK_DEFINITION | jq -r '.containerDefinitions[0].logConfiguration.options."awslogs-group"')
            if [ -n "$LOG_GROUP" ]; then
              LOG_STREAM=$(aws logs describe-log-streams \
                --log-group-name $LOG_GROUP \
                --order-by LastEventTime \
                --descending \
                --limit 5 \
                --query 'logStreams[?contains(logStreamName, `env-test`)].logStreamName | [0]' \
                --output text 2>/dev/null || echo "")
              
              if [ -n "$LOG_STREAM" ] && [ "$LOG_STREAM" != "None" ]; then
                echo "Environment test logs:"
                aws logs get-log-events \
                  --log-group-name $LOG_GROUP \
                  --log-stream-name $LOG_STREAM \
                  --query 'events[*].message' \
                  --output text
              fi
            fi
            
            echo "Environment test failed. Aborting migration."
            exit 1
          fi
          
          echo "Environment test passed. Proceeding with migration..."
          
          # Create a one-time migration task with enhanced logging
          MIGRATION_TASK_DEF=$(echo $TASK_DEFINITION | jq \
            '.containerDefinitions[0].command = ["python", "run_migrations.py"] | 
             .containerDefinitions[0].logConfiguration.options."awslogs-stream-prefix" = "migration" |
             del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | 
             del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
          
          # Register migration task definition
          MIGRATION_TASK_ARN=$(aws ecs register-task-definition \
            --cli-input-json "$MIGRATION_TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "Registered migration task definition: $MIGRATION_TASK_ARN"
          
          # Run migration task
          TASK_ARN=$(aws ecs run-task \
            --cluster $ECS_CLUSTER \
            --task-definition $MIGRATION_TASK_ARN \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$PRIVATE_SUBNET],securityGroups=[$SECURITY_GROUP],assignPublicIp=DISABLED}" \
            --query 'tasks[0].taskArn' \
            --output text)
          
          echo "Migration task started: $TASK_ARN"
          
          # Monitor task progress
          echo "Waiting for migration task to complete..."
          for i in {1..60}; do
            TASK_STATUS=$(aws ecs describe-tasks \
              --cluster $ECS_CLUSTER \
              --tasks $TASK_ARN \
              --query 'tasks[0].lastStatus' \
              --output text)
            
            echo "Task status: $TASK_STATUS (check $i/60)"
            
            if [ "$TASK_STATUS" = "STOPPED" ]; then
              break
            fi
            
            sleep 10
          done
          
          # Get detailed task information
          TASK_DETAILS=$(aws ecs describe-tasks \
            --cluster $ECS_CLUSTER \
            --tasks $TASK_ARN \
            --query 'tasks[0]' \
            --output json)
          
          echo "Task details:"
          echo "$TASK_DETAILS" | jq '.containers[0] | {name, exitCode, reason}'
          
          # Get exit code
          EXIT_CODE=$(echo "$TASK_DETAILS" | jq -r '.containers[0].exitCode // "null"')
          STOP_REASON=$(echo "$TASK_DETAILS" | jq -r '.containers[0].reason // "Unknown"')
          
          echo "Migration task exit code: $EXIT_CODE"
          echo "Stop reason: $STOP_REASON"
          
          # Get CloudWatch logs for debugging
          LOG_GROUP=$(echo $TASK_DEFINITION | jq -r '.containerDefinitions[0].logConfiguration.options."awslogs-group"')
          LOG_STREAM=$(aws logs describe-log-streams \
            --log-group-name $LOG_GROUP \
            --order-by LastEventTime \
            --descending \
            --limit 5 \
            --query 'logStreams[?contains(logStreamName, `migration`)].logStreamName | [0]' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$LOG_STREAM" ] && [ "$LOG_STREAM" != "None" ]; then
            echo "Fetching migration logs from CloudWatch..."
            aws logs get-log-events \
              --log-group-name $LOG_GROUP \
              --log-stream-name $LOG_STREAM \
              --query 'events[*].message' \
              --output text | tail -20
          else
            echo "Could not fetch CloudWatch logs"
          fi
          
          if [ "$EXIT_CODE" != "0" ] && [ "$EXIT_CODE" != "null" ]; then
            echo "Migration failed with exit code: $EXIT_CODE"
            exit 1
          elif [ "$EXIT_CODE" = "null" ]; then
            echo "Migration task did not complete properly (no exit code)"
            exit 1
          fi
          
          echo "Database migration completed successfully"

      - name: Wait for deployment to complete
        run: |
          echo "Waiting for backend service to reach steady state..."
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_BACKEND_SERVICE
          
          echo "Waiting for frontend service to reach steady state..."
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_FRONTEND_SERVICE
          
          echo "Waiting for celery worker service to reach steady state..."
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_CELERY_SERVICE

      - name: Health check
        run: |
          # Get ALB DNS name
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names checkguard-alb \
            --query 'LoadBalancers[0].DNSName' \
            --output text)
          
          echo "ALB DNS: $ALB_DNS"
          
          # Health check with retry logic
          for i in {1..30}; do
            echo "Health check attempt $i..."
            if curl -f -s http://$ALB_DNS/health > /dev/null; then
              echo "‚úÖ Application health check passed!"
              break
            fi
            
            if [ $i -eq 30 ]; then
              echo "‚ùå Health check failed after 30 attempts"
              exit 1
            fi
            
            echo "Health check failed, retrying in 10 seconds..."
            sleep 10
          done
          
          echo "üöÄ Deployment completed successfully!"
          echo "Application URL: http://$ALB_DNS"
          echo "API Documentation: http://$ALB_DNS/docs"

      - name: Notify deployment success
        if: success()
        run: |
          echo "::notice title=Deployment Success::‚úÖ CheckGuard AI deployed successfully to AWS ECS"

      - name: Notify deployment failure
        if: failure()
        run: |
          echo "::error title=Deployment Failed::‚ùå CheckGuard AI deployment to AWS ECS failed"

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: failure()
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Rollback services
        run: |
          echo "üîÑ Rolling back to previous deployment..."
          
          # Force new deployment to rollback to previous version
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_BACKEND_SERVICE \
            --force-new-deployment
          
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_FRONTEND_SERVICE \
            --force-new-deployment
          
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_CELERY_SERVICE \
            --force-new-deployment
          
          echo "‚è≥ Waiting for rollback to complete..."
          
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_BACKEND_SERVICE $ECS_FRONTEND_SERVICE $ECS_CELERY_SERVICE
          
          echo "‚úÖ Rollback completed successfully"

      - name: Notify rollback
        run: |
          echo "::warning title=Rollback Completed::üîÑ Services have been rolled back to the previous version"