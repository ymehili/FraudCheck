name: Deploy to AWS ECS

on:
  push:
    branches: [deploy]
  workflow_dispatch:

env:
  AWS_REGION: us-east-2
  ECR_BACKEND_REPOSITORY: checkguard-backend
  ECR_FRONTEND_REPOSITORY: checkguard-frontend
  ECS_CLUSTER: checkguard-cluster
  ECS_BACKEND_SERVICE: backend
  ECS_FRONTEND_SERVICE: frontend
  ECS_CELERY_SERVICE: celery-worker

permissions:
  id-token: write
  contents: read

jobs:
  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get commit SHA
        id: get-sha
        run: echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Build backend image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.get-sha.outputs.sha_short }}
        run: |
          echo "Building backend image..."
          docker build -t $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG backend/
          docker build -t $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:latest backend/
          
          echo "Pushing backend image to ECR..."
          docker push $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:latest

      - name: Build frontend image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.get-sha.outputs.sha_short }}
        run: |
          echo "Building frontend image..."
          docker build \
            --build-arg NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY="${{ secrets.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY }}" \
            --build-arg NEXT_PUBLIC_API_BASE_URL="${{ secrets.NEXT_PUBLIC_API_BASE_URL }}" \
            -t $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG frontend/
          docker build \
            --build-arg NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY="${{ secrets.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY }}" \
            --build-arg NEXT_PUBLIC_API_BASE_URL="${{ secrets.NEXT_PUBLIC_API_BASE_URL }}" \
            -t $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:latest frontend/
          
          echo "Pushing frontend image to ECR..."
          docker push $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:latest

      - name: Deploy or update backend service
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.get-sha.outputs.sha_short }}
        run: |
          echo "Getting current task definition..."
          TASK_DEFINITION=$(aws ecs describe-task-definition \
            --task-definition $ECS_BACKEND_SERVICE \
            --query 'taskDefinition' \
            --output json)
          
          echo "Updating image in task definition..."
          NEW_TASK_DEFINITION=$(echo $TASK_DEFINITION | jq --arg IMAGE "$ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG" \
            '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
          
          echo "Registering new task definition..."
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json "$NEW_TASK_DEFINITION" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "Checking if backend service exists..."
          if aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_BACKEND_SERVICE --query 'services[0].serviceName' --output text 2>/dev/null | grep -q $ECS_BACKEND_SERVICE; then
            echo "Service exists, updating..."
            aws ecs update-service \
              --cluster $ECS_CLUSTER \
              --service $ECS_BACKEND_SERVICE \
              --task-definition $NEW_TASK_DEF_ARN \
              --force-new-deployment
          else
            echo "Service does not exist. Please run Terraform to create the infrastructure first."
            echo "Run: cd infrastructure/terraform && terraform apply"
            exit 1
          fi

      - name: Deploy or update celery worker service
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.get-sha.outputs.sha_short }}
        run: |
          echo "Checking if celery worker service exists..."
          if aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_CELERY_SERVICE --query 'services[0].serviceName' --output text 2>/dev/null | grep -q $ECS_CELERY_SERVICE; then
            echo "Getting current task definition..."
            TASK_DEFINITION=$(aws ecs describe-task-definition \
              --task-definition $ECS_CELERY_SERVICE \
              --query 'taskDefinition' \
              --output json)
            
            echo "Updating image in task definition..."
            NEW_TASK_DEFINITION=$(echo $TASK_DEFINITION | jq --arg IMAGE "$ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG" \
              '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
            
            echo "Registering new task definition..."
            NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
              --cli-input-json "$NEW_TASK_DEFINITION" \
              --query 'taskDefinition.taskDefinitionArn' \
              --output text)
            
            echo "Updating ECS service..."
            aws ecs update-service \
              --cluster $ECS_CLUSTER \
              --service $ECS_CELERY_SERVICE \
              --task-definition $NEW_TASK_DEF_ARN \
              --force-new-deployment
          else
            echo "Celery worker service does not exist yet. Skipping for now."
            echo "This service will be created when Terraform infrastructure is applied."
          fi

      - name: Deploy or update frontend service
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.get-sha.outputs.sha_short }}
        run: |
          echo "Checking if frontend service exists..."
          if aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_FRONTEND_SERVICE --query 'services[0].serviceName' --output text 2>/dev/null | grep -q $ECS_FRONTEND_SERVICE; then
            echo "Getting current task definition..."
            TASK_DEFINITION=$(aws ecs describe-task-definition \
              --task-definition $ECS_FRONTEND_SERVICE \
              --query 'taskDefinition' \
              --output json)
            
            echo "Updating image in task definition..."
            NEW_TASK_DEFINITION=$(echo $TASK_DEFINITION | jq --arg IMAGE "$ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG" \
              '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
            
            echo "Registering new task definition..."
            NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
              --cli-input-json "$NEW_TASK_DEFINITION" \
              --query 'taskDefinition.taskDefinitionArn' \
              --output text)
            
            echo "Updating ECS service..."
            aws ecs update-service \
              --cluster $ECS_CLUSTER \
              --service $ECS_FRONTEND_SERVICE \
              --task-definition $NEW_TASK_DEF_ARN \
              --force-new-deployment
          else
            echo "Frontend service does not exist yet. Skipping for now."
            echo "This service will be created when Terraform infrastructure is applied."
          fi

      - name: Run database migrations
        run: |
          echo "Running database migrations..."
          
          # Get the current backend task definition
          TASK_DEFINITION=$(aws ecs describe-task-definition \
            --task-definition $ECS_BACKEND_SERVICE \
            --query 'taskDefinition' \
            --output json)
          
          # Debug task definition logging configuration
          echo "Checking task definition logging configuration..."
          LOG_CONFIG=$(echo $TASK_DEFINITION | jq '.containerDefinitions[0].logConfiguration')
          echo "Original log configuration: $LOG_CONFIG"
          
          # Get the original log group name
          ORIGINAL_LOG_GROUP=$(echo $TASK_DEFINITION | jq -r '.containerDefinitions[0].logConfiguration.options."awslogs-group"')
          echo "Original log group: $ORIGINAL_LOG_GROUP"
          
          # Create our custom log group if it doesn't exist
          CUSTOM_LOG_GROUP="/ecs/checkguard-backend"
          echo "Ensuring custom log group exists: $CUSTOM_LOG_GROUP"
          
          aws logs create-log-group --log-group-name $CUSTOM_LOG_GROUP --region us-east-2 || echo "Log group already exists or creation failed"
          
          # First, run a simple connectivity test using the original log group
          echo "Creating simple connectivity test task..."
          SIMPLE_TEST_DEF=$(echo $TASK_DEFINITION | jq \
            --arg log_group "$ORIGINAL_LOG_GROUP" \
            '.containerDefinitions[0].command = ["python", "-c", "import os; print(\"Python works!\"); print(\"DATABASE_URL:\", \"SET\" if os.environ.get(\"DATABASE_URL\") else \"NOT SET\"); import sys; sys.exit(0)"] | 
             .containerDefinitions[0].logConfiguration.options."awslogs-stream-prefix" = "simple-test" |
             del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | 
             del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
          
          # Register simple test task definition
          SIMPLE_TEST_TASK_ARN=$(aws ecs register-task-definition \
            --cli-input-json "$SIMPLE_TEST_DEF" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          # Get network configuration - use public subnets for migration tasks that need AWS services access
          # Try private subnets first, then fall back to public if needed
          PRIVATE_SUBNET=$(aws ec2 describe-subnets \
            --filters "Name=tag:Tier,Values=app" "Name=tag:Type,Values=private" \
            --query 'Subnets[0].SubnetId' \
            --output text)
          
          # If no app subnet found, try general private subnets
          if [ "$PRIVATE_SUBNET" = "None" ] || [ -z "$PRIVATE_SUBNET" ]; then
            PRIVATE_SUBNET=$(aws ec2 describe-subnets \
              --filters "Name=tag:Type,Values=private" \
              --query 'Subnets[?!contains(Tags[?Key==`Tier`].Value || [`unknown`], `database`)].SubnetId | [0]' \
              --output text)
          fi
          
          # If still no private subnet, use public subnet for migration
          if [ "$PRIVATE_SUBNET" = "None" ] || [ -z "$PRIVATE_SUBNET" ]; then
            echo "No suitable private subnet found, using public subnet for migration tasks"
            PRIVATE_SUBNET=$(aws ec2 describe-subnets \
              --filters "Name=tag:Type,Values=public" \
              --query 'Subnets[0].SubnetId' \
              --output text)
          fi
          
          SECURITY_GROUP=$(aws ec2 describe-security-groups \
            --filters "Name=tag:Name,Values=checkguard-ecs-sg" \
            --query 'SecurityGroups[0].GroupId' \
            --output text)
          
          echo "Using subnet: $PRIVATE_SUBNET"
          echo "Using security group: $SECURITY_GROUP"
          
          # Debug subnet information
          echo "Subnet details:"
          aws ec2 describe-subnets --subnet-ids $PRIVATE_SUBNET --query 'Subnets[0].{SubnetId: SubnetId, CidrBlock: CidrBlock, AvailabilityZone: AvailabilityZone, Tags: Tags}' --output json
          
          # Run simple test task with public IP to access AWS services
          SIMPLE_TEST_TASK_ID=$(aws ecs run-task \
            --cluster $ECS_CLUSTER \
            --task-definition $SIMPLE_TEST_TASK_ARN \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$PRIVATE_SUBNET],securityGroups=[$SECURITY_GROUP],assignPublicIp=ENABLED}" \
            --query 'tasks[0].taskArn' \
            --output text)
          
          echo "Simple test task started: $SIMPLE_TEST_TASK_ID"
          
          # Wait for simple test to complete
          aws ecs wait tasks-stopped --cluster $ECS_CLUSTER --tasks $SIMPLE_TEST_TASK_ID
          
          SIMPLE_EXIT_CODE=$(aws ecs describe-tasks \
            --cluster $ECS_CLUSTER \
            --tasks $SIMPLE_TEST_TASK_ID \
            --query 'tasks[0].containers[0].exitCode' \
            --output text)
          
          echo "Simple test exit code: $SIMPLE_EXIT_CODE"
          
          if [ "$SIMPLE_EXIT_CODE" != "0" ] || [ "$SIMPLE_EXIT_CODE" = "null" ]; then
            echo "Basic connectivity test failed. Let's get detailed information..."
            
            # Get detailed task information
            SIMPLE_TASK_DETAILS=$(aws ecs describe-tasks \
              --cluster $ECS_CLUSTER \
              --tasks $SIMPLE_TEST_TASK_ID \
              --query 'tasks[0]' \
              --output json)
            
            echo "Simple test task details:"
            echo "$SIMPLE_TASK_DETAILS" | jq '{
              lastStatus: .lastStatus,
              desiredStatus: .desiredStatus,
              stoppedReason: .stoppedReason,
              containers: .containers[0] | {
                name: .name,
                lastStatus: .lastStatus,
                exitCode: .exitCode,
                reason: .reason,
                networkInterfaces: .networkInterfaces
              }
            }'
            
            # Try to get logs from the original log group
            echo "Trying to get logs from original log group: $ORIGINAL_LOG_GROUP"
            
            # Wait for logs to be available
            sleep 30
            
            # List available log streams
            echo "Available log streams in $ORIGINAL_LOG_GROUP:"
            aws logs describe-log-streams \
              --log-group-name $ORIGINAL_LOG_GROUP \
              --order-by LastEventTime \
              --descending \
              --limit 5 \
              --query 'logStreams[*].{name: logStreamName, lastEvent: lastEventTime}' \
              --output table || echo "Failed to list log streams"
            
            # Try to get the most recent log stream
            RECENT_STREAM=$(aws logs describe-log-streams \
              --log-group-name $ORIGINAL_LOG_GROUP \
              --order-by LastEventTime \
              --descending \
              --limit 1 \
              --query 'logStreams[0].logStreamName' \
              --output text 2>/dev/null || echo "")
            
            if [ -n "$RECENT_STREAM" ] && [ "$RECENT_STREAM" != "None" ]; then
              echo "Getting logs from most recent stream: $RECENT_STREAM"
              aws logs get-log-events \
                --log-group-name $ORIGINAL_LOG_GROUP \
                --log-stream-name $RECENT_STREAM \
                --start-time $(date -d '15 minutes ago' +%s)000 \
                --query 'events[*].message' \
                --output text || echo "Failed to get log events"
            else
              echo "No log streams found"
            fi
            
            echo "Basic connectivity test failed. There's a fundamental issue with the ECS setup."
            exit 1
          fi
          
          echo "Basic connectivity test passed. Proceeding with environment test..."
          
          # Create a test task first to check environment
          echo "Creating environment test task..."
          TEST_TASK_DEF=$(echo $TASK_DEFINITION | jq \
            --arg log_group "$ORIGINAL_LOG_GROUP" \
            '.containerDefinitions[0].command = ["python", "test_db_env.py"] | 
             .containerDefinitions[0].logConfiguration.options."awslogs-stream-prefix" = "env-test" |
             del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | 
             del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
          
          echo "Test task definition logging configuration:"
          echo $TEST_TASK_DEF | jq '.containerDefinitions[0].logConfiguration'
          
          # Register test task definition
          TEST_TASK_ARN=$(aws ecs register-task-definition \
            --cli-input-json "$TEST_TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "Running environment test..."
          
          # Debug task definition logging configuration
          echo "Checking task definition logging configuration..."
          LOG_CONFIG=$(echo $TASK_DEFINITION | jq '.containerDefinitions[0].logConfiguration')
          echo "Log configuration: $LOG_CONFIG"
          
          # Get network configuration
          PRIVATE_SUBNET=$(aws ec2 describe-subnets \
            --filters "Name=tag:Type,Values=private" \
            --query 'Subnets[0].SubnetId' \
            --output text)
          
          SECURITY_GROUP=$(aws ec2 describe-security-groups \
            --filters "Name=tag:Name,Values=checkguard-ecs-sg" \
            --query 'SecurityGroups[0].GroupId' \
            --output text)
          
          echo "Using subnet: $PRIVATE_SUBNET"
          echo "Using security group: $SECURITY_GROUP"
          
          # Run test task with public IP for AWS services access
          TEST_TASK_ID=$(aws ecs run-task \
            --cluster $ECS_CLUSTER \
            --task-definition $TEST_TASK_ARN \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$PRIVATE_SUBNET],securityGroups=[$SECURITY_GROUP],assignPublicIp=ENABLED}" \
            --query 'tasks[0].taskArn' \
            --output text)
          
          echo "Environment test task started: $TEST_TASK_ID"
          
          # Wait for test to complete
          aws ecs wait tasks-stopped --cluster $ECS_CLUSTER --tasks $TEST_TASK_ID
          
          # Get detailed task information first
          TEST_TASK_DETAILS=$(aws ecs describe-tasks \
            --cluster $ECS_CLUSTER \
            --tasks $TEST_TASK_ID \
            --query 'tasks[0]' \
            --output json)
          
          TEST_EXIT_CODE=$(echo "$TEST_TASK_DETAILS" | jq -r '.containers[0].exitCode // "null"')
          TEST_STOP_REASON=$(echo "$TEST_TASK_DETAILS" | jq -r '.containers[0].reason // "Unknown"')
          TASK_STATUS=$(echo "$TEST_TASK_DETAILS" | jq -r '.lastStatus // "Unknown"')
          
          echo "Environment test task status: $TASK_STATUS"
          echo "Environment test exit code: $TEST_EXIT_CODE"
          echo "Environment test stop reason: $TEST_STOP_REASON"
          
          if [ "$TEST_EXIT_CODE" != "0" ] || [ "$TEST_EXIT_CODE" = "null" ]; then
            echo "Environment test failed or didn't complete properly. Checking logs..."
            
            # Extract task ID from ARN for log stream matching
            TASK_SHORT_ID=$(echo $TEST_TASK_ID | sed 's/.*\///')
            echo "Task short ID: $TASK_SHORT_ID"
            
            # Try to get logs with improved logic
            LOG_GROUP=$(echo $TASK_DEFINITION | jq -r '.containerDefinitions[0].logConfiguration.options."awslogs-group"')
            LOG_STREAM_PREFIX=$(echo $TASK_DEFINITION | jq -r '.containerDefinitions[0].logConfiguration.options."awslogs-stream-prefix" // "ecs"')
            
            echo "Log group: $LOG_GROUP"
            echo "Log stream prefix: $LOG_STREAM_PREFIX"
            
            if [ -n "$LOG_GROUP" ] && [ "$LOG_GROUP" != "null" ]; then
              # Wait a bit for logs to be written
              echo "Waiting 30 seconds for logs to be available..."
              sleep 30
              
              # List available log streams for debugging
              echo "Available log streams:"
              aws logs describe-log-streams \
                --log-group-name $LOG_GROUP \
                --order-by LastEventTime \
                --descending \
                --limit 10 \
                --query 'logStreams[*].logStreamName' \
                --output text || echo "Failed to list log streams"
              
              # Try multiple approaches to find the right log stream
              LOG_STREAM=""
              
              # Approach 1: Look for env-test prefix
              LOG_STREAM=$(aws logs describe-log-streams \
                --log-group-name $LOG_GROUP \
                --order-by LastEventTime \
                --descending \
                --limit 10 \
                --query 'logStreams[?contains(logStreamName, `env-test`)].logStreamName | [0]' \
                --output text 2>/dev/null || echo "")
              
              # Approach 2: Look for task ID in stream name
              if [ -z "$LOG_STREAM" ] || [ "$LOG_STREAM" = "None" ]; then
                LOG_STREAM=$(aws logs describe-log-streams \
                  --log-group-name $LOG_GROUP \
                  --order-by LastEventTime \
                  --descending \
                  --limit 10 \
                  --query "logStreams[?contains(logStreamName, \`$TASK_SHORT_ID\`)].logStreamName | [0]" \
                  --output text 2>/dev/null || echo "")
              fi
              
              # Approach 3: Get the most recent stream
              if [ -z "$LOG_STREAM" ] || [ "$LOG_STREAM" = "None" ]; then
                LOG_STREAM=$(aws logs describe-log-streams \
                  --log-group-name $LOG_GROUP \
                  --order-by LastEventTime \
                  --descending \
                  --limit 1 \
                  --query 'logStreams[0].logStreamName' \
                  --output text 2>/dev/null || echo "")
              fi
              
              if [ -n "$LOG_STREAM" ] && [ "$LOG_STREAM" != "None" ] && [ "$LOG_STREAM" != "null" ]; then
                echo "Found log stream: $LOG_STREAM"
                echo "Environment test logs:"
                aws logs get-log-events \
                  --log-group-name $LOG_GROUP \
                  --log-stream-name $LOG_STREAM \
                  --start-time $(date -d '10 minutes ago' +%s)000 \
                  --query 'events[*].message' \
                  --output text 2>/dev/null || echo "Failed to get log events"
              else
                echo "Could not find log stream for task"
              fi
            else
              echo "No log group configured"
            fi
            
            # Show task definition details for debugging
            echo "Task definition details:"
            echo "$TEST_TASK_DETAILS" | jq '.containers[0] | {name, image, exitCode, reason}'
            
            echo "Environment test failed. Aborting migration."
            exit 1
          fi
          
          echo "Environment test passed. Proceeding with migration..."
          
          # Create a one-time migration task with enhanced logging
          MIGRATION_TASK_DEF=$(echo $TASK_DEFINITION | jq \
            --arg log_group "$ORIGINAL_LOG_GROUP" \
            '.containerDefinitions[0].command = ["python", "run_migrations.py"] | 
             .containerDefinitions[0].logConfiguration.options."awslogs-stream-prefix" = "migration" |
             del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | 
             del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
          
          echo "Migration task definition logging configuration:"
          echo $MIGRATION_TASK_DEF | jq '.containerDefinitions[0].logConfiguration'
          
          # Register migration task definition
          MIGRATION_TASK_ARN=$(aws ecs register-task-definition \
            --cli-input-json "$MIGRATION_TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "Registered migration task definition: $MIGRATION_TASK_ARN"
          
          # Run migration task with public IP for AWS services access
          TASK_ARN=$(aws ecs run-task \
            --cluster $ECS_CLUSTER \
            --task-definition $MIGRATION_TASK_ARN \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$PRIVATE_SUBNET],securityGroups=[$SECURITY_GROUP],assignPublicIp=ENABLED}" \
            --query 'tasks[0].taskArn' \
            --output text)
          
          echo "Migration task started: $TASK_ARN"
          
          # Monitor task progress
          echo "Waiting for migration task to complete..."
          for i in {1..60}; do
            TASK_STATUS=$(aws ecs describe-tasks \
              --cluster $ECS_CLUSTER \
              --tasks $TASK_ARN \
              --query 'tasks[0].lastStatus' \
              --output text)
            
            echo "Task status: $TASK_STATUS (check $i/60)"
            
            if [ "$TASK_STATUS" = "STOPPED" ]; then
              break
            fi
            
            sleep 10
          done
          
          # Get detailed task information
          TASK_DETAILS=$(aws ecs describe-tasks \
            --cluster $ECS_CLUSTER \
            --tasks $TASK_ARN \
            --query 'tasks[0]' \
            --output json)
          
          echo "Task details:"
          echo "$TASK_DETAILS" | jq '.containers[0] | {name, exitCode, reason}'
          
          # Get exit code
          EXIT_CODE=$(echo "$TASK_DETAILS" | jq -r '.containers[0].exitCode // "null"')
          STOP_REASON=$(echo "$TASK_DETAILS" | jq -r '.containers[0].reason // "Unknown"')
          
          echo "Migration task exit code: $EXIT_CODE"
          echo "Stop reason: $STOP_REASON"
          
          # Get CloudWatch logs for debugging
          echo "Fetching migration logs..."
          
          # Extract task ID from ARN for log stream matching
          MIGRATION_TASK_SHORT_ID=$(echo $TASK_ARN | sed 's/.*\///')
          echo "Migration task short ID: $MIGRATION_TASK_SHORT_ID"
          
          LOG_GROUP=$(echo $TASK_DEFINITION | jq -r '.containerDefinitions[0].logConfiguration.options."awslogs-group"')
          
          if [ -n "$LOG_GROUP" ] && [ "$LOG_GROUP" != "null" ]; then
            # Wait for logs to be available
            echo "Waiting 30 seconds for logs to be written..."
            sleep 30
            
            # List available log streams for debugging
            echo "Available recent log streams:"
            aws logs describe-log-streams \
              --log-group-name $LOG_GROUP \
              --order-by LastEventTime \
              --descending \
              --limit 10 \
              --query 'logStreams[*].logStreamName' \
              --output text || echo "Failed to list log streams"
            
            # Try multiple approaches to find the right log stream
            LOG_STREAM=""
            
            # Approach 1: Look for migration prefix
            LOG_STREAM=$(aws logs describe-log-streams \
              --log-group-name $LOG_GROUP \
              --order-by LastEventTime \
              --descending \
              --limit 10 \
              --query 'logStreams[?contains(logStreamName, `migration`)].logStreamName | [0]' \
              --output text 2>/dev/null || echo "")
            
            # Approach 2: Look for task ID in stream name
            if [ -z "$LOG_STREAM" ] || [ "$LOG_STREAM" = "None" ]; then
              LOG_STREAM=$(aws logs describe-log-streams \
                --log-group-name $LOG_GROUP \
                --order-by LastEventTime \
                --descending \
                --limit 10 \
                --query "logStreams[?contains(logStreamName, \`$MIGRATION_TASK_SHORT_ID\`)].logStreamName | [0]" \
                --output text 2>/dev/null || echo "")
            fi
            
            # Approach 3: Get the most recent stream
            if [ -z "$LOG_STREAM" ] || [ "$LOG_STREAM" = "None" ]; then
              LOG_STREAM=$(aws logs describe-log-streams \
                --log-group-name $LOG_GROUP \
                --order-by LastEventTime \
                --descending \
                --limit 1 \
                --query 'logStreams[0].logStreamName' \
                --output text 2>/dev/null || echo "")
            fi
            
            if [ -n "$LOG_STREAM" ] && [ "$LOG_STREAM" != "None" ] && [ "$LOG_STREAM" != "null" ]; then
              echo "Found migration log stream: $LOG_STREAM"
              echo "Migration logs:"
              aws logs get-log-events \
                --log-group-name $LOG_GROUP \
                --log-stream-name $LOG_STREAM \
                --start-time $(date -d '15 minutes ago' +%s)000 \
                --query 'events[*].message' \
                --output text | tail -30
            else
              echo "Could not find migration log stream"
            fi
          else
            echo "No log group configured for migration task"
          fi
          
          if [ "$EXIT_CODE" != "0" ] && [ "$EXIT_CODE" != "null" ]; then
            echo "Migration failed with exit code: $EXIT_CODE"
            exit 1
          elif [ "$EXIT_CODE" = "null" ]; then
            echo "Migration task did not complete properly (no exit code)"
            exit 1
          fi
          
          echo "Database migration completed successfully"

      - name: Wait for deployment to complete
        run: |
          echo "Waiting for backend service to reach steady state..."
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_BACKEND_SERVICE
          
          echo "Waiting for frontend service to reach steady state..."
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_FRONTEND_SERVICE
          
          echo "Waiting for celery worker service to reach steady state..."
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_CELERY_SERVICE

      - name: Health check
        run: |
          # Get ALB DNS name
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names checkguard-alb \
            --query 'LoadBalancers[0].DNSName' \
            --output text)
          
          echo "ALB DNS: $ALB_DNS"
          
          # Health check with retry logic
          for i in {1..30}; do
            echo "Health check attempt $i..."
            if curl -f -s http://$ALB_DNS/health > /dev/null; then
              echo "‚úÖ Application health check passed!"
              break
            fi
            
            if [ $i -eq 30 ]; then
              echo "‚ùå Health check failed after 30 attempts"
              exit 1
            fi
            
            echo "Health check failed, retrying in 10 seconds..."
            sleep 10
          done
          
          echo "üöÄ Deployment completed successfully!"
          echo "Application URL: http://$ALB_DNS"
          echo "API Documentation: http://$ALB_DNS/docs"

      - name: Notify deployment success
        if: success()
        run: |
          echo "::notice title=Deployment Success::‚úÖ CheckGuard AI deployed successfully to AWS ECS"

      - name: Notify deployment failure
        if: failure()
        run: |
          echo "::error title=Deployment Failed::‚ùå CheckGuard AI deployment to AWS ECS failed"

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: failure()
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Rollback services
        run: |
          echo "üîÑ Rolling back to previous deployment..."
          
          # Force new deployment to rollback to previous version
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_BACKEND_SERVICE \
            --force-new-deployment
          
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_FRONTEND_SERVICE \
            --force-new-deployment
          
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_CELERY_SERVICE \
            --force-new-deployment
          
          echo "‚è≥ Waiting for rollback to complete..."
          
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_BACKEND_SERVICE $ECS_FRONTEND_SERVICE $ECS_CELERY_SERVICE
          
          echo "‚úÖ Rollback completed successfully"

      - name: Notify rollback
        run: |
          echo "::warning title=Rollback Completed::üîÑ Services have been rolled back to the previous version"